REBOL [
	file: %classes.r
	author: "Maxim Olivier-Adlhoch"
	date: 2011-04-22
	version: 0.6.1
	title: "Stores object base classes used by !unit object."
	
	license-type: 'MIT
	license:      {Copyright © 2011 Maxim Olivier-Adlhoch.

		Permission is hereby granted, free of charge, to any person obtaining a copy of this software 
		and associated documentation files (the "Software"), to deal in the Software without restriction, 
		including without limitation the rights to use, copy, modify, merge, publish, distribute, 
		sublicense, and/or sell copies of the Software, and to permit persons to whom the Software 
		is furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in all copies or 
		substantial portions of the Software.}
		
	disclaimer: {THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
		INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
		PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE 
		FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
		ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
		THE SOFTWARE.}

]




;-    !http-port-spec:
; defines and stores the low-level TCP/HTTP information required to build
; a request to the server.
;
; this can be reused between requests, so that we don't need to rebuild 
; and respecify it in each unit.
!http-port-spec: context [
	;-        scheme:
	scheme: 'http


	;-        host:
	; server's DNS name or an IP address 
	host: none

	
	;-        port-id:
	; tcp port to use on connection.
	port-id: none

	
	;-        uri:
	; the Uniform Resource Identifier used in request (path + target part of a URL).
	;
	; This DOES NOT store url parameter passing, that is appended within the !unit
	; execute() chain.
	uri: none
	
	
	;-        user:
	; when connecting, do we need a user-name
	user: none
	
	
	;-        pass:
	; when connecting, do we need a password
	pass: none
]





;-    !http-request:
; the basis for the request, is not mangled during http request/reponse,
; so you can use any unit-test over and over.
;
; this basically STORES data, but doesn't provide the methods, which are what
; the !unit is all about.
;
; the !request is copied when a new conncetion is attempted, and that is stored
; in unit/request
!http-request: context [
	;-        time:
	time: none
	
	
	;-        content-buffer:
	; stores low-level data sent to server.
	;
	; content is usually generated first, so that header can include content-related 
	; information.
	;
	; this is generated by build-http-content()
	content-buffer: none
	
	
	
	;-        content-type
	Content-Type: "application/x-www-form-urlencoded"

	
	;-        request-line
	;
	; the first line of any http request.
	;
	; <RFC 1945 section 5.1>
	request-line: none


	;-        header:
	; stores the header fields sent by this test in their logical (rebol) form.
	;
	; some fields are concatenated when the header is formed prior to the tcp call.
	;
	; any required data conversion is done by build-http-header
	;
	; it is possible that some header fields will be added when the request is executed.
	header: context [
		; simulate FireFox 3.6.3
		User-Agent: "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.3) Gecko/20100401 Firefox/3.6.3"
		Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
		Accept-Language: "en,en-us;q=0.5"
	]
	
	;-        user-header:
	; if this is an object, it will be applied to the request after all other
	; request processing occurs, effectively overriding any automated unit test
	; functionality with your own specific header overides.
	;
	; when the request is made, the user-header is effectively added to the header,
	; after all other processing is done.
	user-header: none
	
	
	
	;-        header-buffer:
	; stores low-level data sent to server.
	;
	; this is generated by build-http-header()
	header-buffer: none
	
	
	
	;-        params:
	;
	; to make interaction with dynamic pages easier, you can put some parameters to use in your 
	; requests here.
	;
	; depending on the type of request/response, the params may be used differently.
	;
	; for example, in a GET/HEAD request, these are used to add params to the url, by default.
	; in a POST request, it will build a form-type post request by default.
	; 
	; an example for a simple login request:
	;
	; params: context [
	;		login: "username"
	;		passwd: "passwd"
	;	]
	;
	params: none
	


	;-----------------
	;-        init()
	;-----------------
	init: func [
	][
		vin [{!request/init()}]
		;time: now/precise ; will be sent on send() instead.
		header: make header []
		vout
	]
]


;-    !http-response:
; 
; reference object for response analysis.
!http-response: context [
	;-        time:
	time: none
	
	;-        packet-size:
	; much much data to get at a time
	packet-size: 1024
	
	;-        buffer:
	buffer: none
	
	;-        success?:
	; stores if load-response() was able to properly parser response buffer
	success?: false

	;-        error:
	error: none
	
	;-        header:
	header: none
	
	;-        method:
	method: none
	
	;-        status-version:
	status-version: none
	
	;-        status-code:
	status-code: none
	
	;-        status-text:
	status-text: none
	
	;-        status-line:
	status-line: none
	
	;-        content:
	content: none
	
	
	;-----------------
	;-        init()
	;-----------------
	init: func [
	][
		vin [{!response/init()}]
		buffer: copy #{} ; {}
		header: context []
		vout
	]
	
	
]
	







	